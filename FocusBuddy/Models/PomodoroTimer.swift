import Foundation
import SwiftUI
import UserNotifications
import AVFoundation

enum TimerPhase: String, CaseIterable {
    case focus = "focus"
    case shortBreak = "shortBreak"
    case longBreak = "longBreak"
    
    var emoji: String {
        switch self {
        case .focus: return ""
        case .shortBreak: return ""
        case .longBreak: return ""
        }
    }
    
    var title: String {
        switch self {
        case .focus: return "–§–æ–∫—É—Å"
        case .shortBreak: return "–ö–æ—Ä–æ—Ç–∫–∏–π –ø–µ—Ä–µ—Ä—ã–≤"
        case .longBreak: return "–î–ª–∏–Ω–Ω—ã–π –ø–µ—Ä–µ—Ä—ã–≤"
        }
    }
    
    var description: String {
        switch self {
        case .focus: return "–í—Ä–µ–º—è —Å–æ—Å—Ä–µ–¥–æ—Ç–æ—á–∏—Ç—å—Å—è –Ω–∞ –∑–∞–¥–∞—á–µ"
        case .shortBreak: return "–ù–µ–±–æ–ª—å—à–æ–π –æ—Ç–¥—ã—Ö –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è"
        case .longBreak: return "–ó–∞—Å–ª—É–∂–µ–Ω–Ω—ã–π –¥–ª–∏–Ω–Ω—ã–π –æ—Ç–¥—ã—Ö"
        }
    }
}

enum TimerState {
    case stopped
    case running
    case paused
    case stoppedForToday
}

struct TimerPreset: Equatable {
    let name: String
    let emoji: String
    let focusMinutes: Int
    let shortBreakMinutes: Int
    let longBreakMinutes: Int
    let description: String
    
    static let classic = TimerPreset(
        name: "25/5",
        emoji: "‚è∞",
        focusMinutes: 25,
        shortBreakMinutes: 5,
        longBreakMinutes: 15,
        description: "–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π —Ä–µ–∂–∏–º"
    )
    
    static let deepWork = TimerPreset(
        name: "50/10",
        emoji: "üß†",
        focusMinutes: 50,
        shortBreakMinutes: 10,
        longBreakMinutes: 20,
        description: "–ì–ª—É–±–æ–∫–∞—è —Ä–∞–±–æ—Ç–∞"
    )
    
    static let sprint = TimerPreset(
        name: "15/3",
        emoji: "‚ö°",
        focusMinutes: 15,
        shortBreakMinutes: 3,
        longBreakMinutes: 10,
        description: "–ë—ã—Å—Ç—Ä—ã–µ —Å–ø—Ä–∏–Ω—Ç—ã"
    )
}

class FocusTimer: ObservableObject {
    @Published var currentPhase: TimerPhase = .focus
    @Published var timeRemaining: Int = 25 * 60 // seconds
    @Published var timerState: TimerState = .stopped
    @Published var completedCycles: Int = 0
    @Published var currentPreset: TimerPreset = .classic
    @Published var todayFocusMinutes: Int = 0
    @Published var weekFocusMinutes: Int = 0
    @Published var currentStreak: Int = 0
    
    // Debug output
    @Published var debugOutput: String = "Debug log:\n"
    
    private var timer: Timer?
    private var dailyResetTimer: Timer?
    private var startTime: Date?
    private var pausedTime: Date?
    
    // Settings
    @Published var soundEnabled: Bool = true {
        didSet { saveSettings() }
    }
    @Published var notificationsEnabled: Bool = true {
        didSet { saveSettings() }
    }
    @Published var autoStartBreaks: Bool = true {
        didSet { saveSettings() }
    }
    @Published var autoStartFocus: Bool = true {
        didSet { saveSettings() }
    }
    
    
    init() {
        resetTimer()
        loadSettings()
        loadStatistics()
        addDebugLog("üöÄ FocusTimer –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    }
    
    deinit {
        timer?.invalidate()
        dailyResetTimer?.invalidate()
    }
    
    // MARK: - Timer Controls
    
    func startTimer() {
        guard timerState != .stoppedForToday else { return }

        // Stop any existing timer first
        stopTimer()

        timerState = .running
        startTime = Date()

        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            self?.updateTimer()
        }

        scheduleNotification()
    }
    
    func pauseTimer() {
        timer?.invalidate()
        timer = nil
        timerState = .paused
        pausedTime = Date()
        cancelNotification()
    }
    
    func resumeTimer() {
        guard timerState == .paused else { return }

        timerState = .running

        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            self?.updateTimer()
        }

        scheduleNotification()
    }
    
    func stopTimer() {
        timer?.invalidate()
        timer = nil
        timerState = .stopped
        resetCurrentPhase()
        cancelNotification()
    }
    
    func stopForToday() {
        timer?.invalidate()
        timer = nil
        timerState = .stoppedForToday
        cancelNotification()
        
        // Reset at midnight
        scheduleResetForTomorrow()
    }
    
    private func updateTimer() {
        DispatchQueue.main.async { [weak self] in
            guard let self = self, self.timerState == .running, self.timeRemaining > 0 else {
                self?.completeCurrentPhase()
                return
            }
            self.timeRemaining -= 1
        }
    }
    
    private func completeCurrentPhase() {
        // Prevent multiple completions
        guard timerState == .running else { return }

        timer?.invalidate()
        timer = nil

        // Record completed session
        recordCompletedSession()

        // Determine next phase
        let nextPhase = getNextPhase()

        // Show notification
        showPhaseCompletionNotification(nextPhase: nextPhase)

        // Update phase and reset timer
        currentPhase = nextPhase
        resetCurrentPhase()

        // Auto-start next phase if enabled
        if shouldAutoStartNextPhase() {
            timerState = .stopped
            DispatchQueue.main.asyncAfter(deadline: .now() + 2) { [weak self] in
                guard let self = self, self.timerState == .stopped else { return }
                self.startTimer()
            }
        } else {
            timerState = .stopped
        }
    }
    
    private func getNextPhase() -> TimerPhase {
        switch currentPhase {
        case .focus:
            completedCycles += 1
            return (completedCycles % 4 == 0) ? .longBreak : .shortBreak
        case .shortBreak, .longBreak:
            return .focus
        }
    }
    
    private func shouldAutoStartNextPhase() -> Bool {
        switch currentPhase {
        case .focus:
            return autoStartBreaks
        case .shortBreak, .longBreak:
            return autoStartFocus
        }
    }
    
    // MARK: - Preset Management
    
    func changePreset(_ preset: TimerPreset) {
        currentPreset = preset
        resetTimer()
    }
    
    private func resetCurrentPhase() {
        let minutes: Int
        switch currentPhase {
        case .focus:
            minutes = currentPreset.focusMinutes
        case .shortBreak:
            minutes = currentPreset.shortBreakMinutes
        case .longBreak:
            minutes = currentPreset.longBreakMinutes
        }
        timeRemaining = minutes * 60
    }
    
    private func resetTimer() {
        currentPhase = .focus
        resetCurrentPhase()
        timerState = .stopped
    }
    
    // MARK: - Debug Functions
    
    private func addDebugLog(_ message: String) {
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:mm:ss"
        let timestamp = formatter.string(from: Date())
        DispatchQueue.main.async {
            self.debugOutput += "[\(timestamp)] \(message)\n"
        }
        print("[\(timestamp)] \(message)")
    }
    
    func requestNotificationPermissions() {
        addDebugLog("üîê –ó–∞–ø—Ä–æ—Å —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è...")
        
        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { [weak self] granted, error in
            DispatchQueue.main.async {
                if let error = error {
                    let errorCode = (error as NSError).code
                    self?.addDebugLog("‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π: \(error.localizedDescription) (–∫–æ–¥: \(errorCode))")
                    
                    if errorCode == 1 { // UNErrorCodeNotificationsNotAllowed
                        self?.addDebugLog("üí° –†–µ—à–µ–Ω–∏–µ: –æ—Ç–∫—Ä–æ–π—Ç–µ –°–∏—Å—Ç–µ–º–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ ‚Üí –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è ‚Üí Focus Buddy")
                        self?.addDebugLog("üí° –ò–ª–∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –∑–∞–ø—É—Å—Ç–∏—Ç—å: open 'x-apple.systempreferences:com.apple.preference.notifications'")
                    }
                } else if granted {
                    self?.addDebugLog("‚úÖ –†–∞–∑—Ä–µ—à–µ–Ω–∏—è –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª—É—á–µ–Ω—ã")
                } else {
                    self?.addDebugLog("‚ùå –†–∞–∑—Ä–µ—à–µ–Ω–∏—è –Ω–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç–∫–ª–æ–Ω–µ–Ω—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")
                }
            }
        }
    }
    
    func openNotificationSettings() {
        addDebugLog("üîß –û—Ç–∫—Ä—ã—Ç–∏–µ –Ω–∞—Å—Ç—Ä–æ–µ–∫ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π...")
        
        if let url = URL(string: "x-apple.systempreferences:com.apple.preference.notifications") {
            NSWorkspace.shared.open(url)
            addDebugLog("‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –æ—Ç–∫—Ä—ã—Ç—ã. –ù–∞–π–¥–∏—Ç–µ 'Focus Buddy' –≤ —Å–ø–∏—Å–∫–µ –∏ –≤–∫–ª—é—á–∏—Ç–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è")
        } else {
            addDebugLog("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π")
        }
    }
    
    
    func sendNotification(title: String, body: String) {
        guard notificationsEnabled else {
            addDebugLog("üîï –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç–∫–ª—é—á–µ–Ω—ã, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º: \(title)")
            return
        }

        addDebugLog("üì¢ –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: \(title)")

        let content = UNMutableNotificationContent()
        content.title = title
        content.body = body
        content.sound = soundEnabled ? .default : nil

        let request = UNNotificationRequest(
            identifier: "focus-buddy-\(Date().timeIntervalSince1970)",
            content: content,
            trigger: nil
        )

        UNUserNotificationCenter.current().add(request) { [weak self] error in
            DispatchQueue.main.async {
                if let error = error {
                    self?.addDebugLog("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: \(error.localizedDescription)")
                } else {
                    self?.addDebugLog("‚úÖ –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ!")
                }
            }
        }
    }
    
    func testNotification() {
        sendNotification(title: "üß™ Focus Buddy Test", body: "–ï—Å–ª–∏ –≤—ã –≤–∏–¥–∏—Ç–µ —ç—Ç–æ - —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Ä–∞–±–æ—Ç–∞—é—Ç!")
    }
    
    func debugPhaseCompletion(nextPhase: TimerPhase) {
        addDebugLog("üß™ –°–∏–º—É–ª—è—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ñ–∞–∑—ã \(currentPhase.title) -> \(nextPhase.title)")
        
        // Record the phase completion
        let currentPhaseName = currentPhase.title
        
        // Call the real notification system
        showPhaseCompletionNotification(nextPhase: nextPhase)
        
        addDebugLog("‚úÖ –°–∏–º—É–ª—è—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –¥–ª—è —Ñ–∞–∑—ã: \(currentPhaseName)")
    }
    
    func testRealNotificationFlow() {
        addDebugLog("üî• –¢–ï–°–¢: –ü–æ–ª–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –ø—Ä–∏ —Å–º–µ–Ω–µ —Ñ–∞–∑—ã")
        
        // Test Focus to Break transition
        addDebugLog("--- –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–µ—Ä–µ—Ö–æ–¥ –§–æ–∫—É—Å -> –ü–µ—Ä–µ—Ä—ã–≤ ---")
        currentPhase = .focus
        showPhaseCompletionNotification(nextPhase: .shortBreak)
        
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) { [weak self] in
            self?.addDebugLog("--- –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–µ—Ä–µ—Ö–æ–¥ –ü–µ—Ä–µ—Ä—ã–≤ -> –§–æ–∫—É—Å ---")
            self?.currentPhase = .shortBreak
            self?.showPhaseCompletionNotification(nextPhase: .focus)
        }
        
        addDebugLog("üèÅ –¢–µ—Å—Ç –∑–∞–ø—É—â–µ–Ω - –æ–∂–∏–¥–∞–π—Ç–µ 2 —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Å –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–º –≤ 3 —Å–µ–∫—É–Ω–¥—ã")
    }
    
    func startQuickTest() {
        addDebugLog("‚ö° –ë–´–°–¢–†–´–ô –¢–ï–°–¢: –ó–∞–ø—É—Å–∫ 10-—Å–µ–∫—É–Ω–¥–Ω–æ–≥–æ —Ñ–æ–∫—É—Å-—Ç–∞–π–º–µ—Ä–∞")
        
        // Stop any current timer
        stopTimer()
        
        // Set to focus phase with 10 seconds
        currentPhase = .focus
        timeRemaining = 10
        timerState = .running
        
        // Start timer
        startTimer()
        
        addDebugLog("‚è∞ –¢–∞–π–º–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ 10 —Å–µ–∫—É–Ω–¥. –û–∂–∏–¥–∞–π—Ç–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏!")
    }
    
    
    func debugNotificationPermissions() {
        addDebugLog("üîî –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π...")
        
        UNUserNotificationCenter.current().getNotificationSettings { [weak self] settings in
            DispatchQueue.main.async {
                let status = self?.authStatusToString(settings.authorizationStatus) ?? "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
                self?.addDebugLog("üìã –†–∞–∑—Ä–µ—à–µ–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π:")
                self?.addDebugLog("   - –°—Ç–∞—Ç—É—Å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏: \(status)")
                self?.addDebugLog("   - –ê–ª–µ—Ä—Ç—ã: \(self?.settingToString(settings.alertSetting) ?? "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")")
                self?.addDebugLog("   - –ó–≤—É–∫–∏: \(self?.settingToString(settings.soundSetting) ?? "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")")
                self?.addDebugLog("   - –ë–µ–π–¥–∂–∏: \(self?.settingToString(settings.badgeSetting) ?? "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")")
                self?.addDebugLog("   - Banner: \(self?.settingToString(settings.notificationCenterSetting) ?? "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")")
                self?.addDebugLog("   - Lock Screen: \(self?.settingToString(settings.lockScreenSetting) ?? "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")")
                self?.addDebugLog("   - –í–∫–ª—é—á–µ–Ω—ã –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏: \(self?.notificationsEnabled ?? false)")
                
            }
        }
    }
    
    
    func debugCurrentTimerState() {
        addDebugLog("‚è±Ô∏è –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ç–∞–π–º–µ—Ä–∞:")
        addDebugLog("   - –§–∞–∑–∞: \(currentPhase.title)")
        addDebugLog("   - –°–æ—Å—Ç–æ—è–Ω–∏–µ: \(timerStateToString(timerState))")
        let minutes = timeRemaining / 60
        let seconds = timeRemaining % 60
        let timeFormatted = String(format: "%d:%02d", minutes, seconds)
        addDebugLog("   - –û—Å—Ç–∞–ª–æ—Å—å –≤—Ä–µ–º–µ–Ω–∏: \(timeRemaining) —Å–µ–∫—É–Ω–¥ (\(timeFormatted))")
        addDebugLog("   - –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ —Ü–∏–∫–ª—ã: \(completedCycles)")
        addDebugLog("   - –ê–≤—Ç–æ-—Å—Ç–∞—Ä—Ç –ø–µ—Ä–µ—Ä—ã–≤–æ–≤: \(autoStartBreaks)")
        addDebugLog("   - –ê–≤—Ç–æ-—Å—Ç–∞—Ä—Ç —Ä–∞–±–æ—Ç—ã: \(autoStartFocus)")
        addDebugLog("   - –ü—Ä–µ—Å–µ—Ç: \(currentPreset.name)")
    }
    
    private func authStatusToString(_ status: UNAuthorizationStatus) -> String {
        switch status {
        case .notDetermined: return "–Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ"
        case .denied: return "–∑–∞–ø—Ä–µ—â–µ–Ω–æ"
        case .authorized: return "—Ä–∞–∑—Ä–µ—à–µ–Ω–æ"
        case .provisional: return "–≤—Ä–µ–º–µ–Ω–Ω–æ–µ"
        case .ephemeral: return "—ç—Ñ–µ–º–µ—Ä–Ω–æ–µ"
        @unknown default: return "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
        }
    }
    
    private func settingToString(_ setting: UNNotificationSetting) -> String {
        switch setting {
        case .notSupported: return "–Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è"
        case .disabled: return "–æ—Ç–∫–ª—é—á–µ–Ω–æ"
        case .enabled: return "–≤–∫–ª—é—á–µ–Ω–æ"
        @unknown default: return "–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
        }
    }
    
    private func timerStateToString(_ state: TimerState) -> String {
        switch state {
        case .stopped: return "–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"
        case .running: return "—Ä–∞–±–æ—Ç–∞–µ—Ç"
        case .paused: return "–Ω–∞ –ø–∞—É–∑–µ"
        case .stoppedForToday: return "–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –Ω–∞ —Å–µ–≥–æ–¥–Ω—è"
        }
    }
    
    // MARK: - Notifications
    
    private func showPhaseCompletionNotification(nextPhase: TimerPhase) {
        guard notificationsEnabled else {
            addDebugLog("üîï –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ñ–∞–∑—ã –ø—Ä–æ–ø—É—â–µ–Ω–æ (–æ—Ç–∫–ª—é—á–µ–Ω—ã)")
            return
        }
        
        let (title, body) = getNotificationContent(for: nextPhase)
        addDebugLog("üì¢ –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è: \(title)")

        // Use unified notification method
        sendNotification(title: title, body: body)
    }
    
    
    
    private func getNotificationContent(for nextPhase: TimerPhase) -> (title: String, body: String) {
        switch currentPhase {
        case .focus:
            return ("üéâ –û—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞!", "–°–µ–π—á–∞—Å –≤—Ä–µ–º—è –æ—Ç–¥–æ—Ö–Ω—É—Ç—å - \(nextPhase.title.lowercased())")
        case .shortBreak, .longBreak:
            return ("‚è∞ –ü–µ—Ä–µ—Ä—ã–≤ –æ–∫–æ–Ω—á–µ–Ω", "–°–µ–π—á–∞—Å –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç–∞—Ç—å - –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –∑–∞–¥–∞—á–∞–º")
        }
    }
    
    
    private func scheduleNotification() {
        // We don't use scheduled notifications anymore since they don't work reliably
        // Notifications are sent immediately when phase completes in completeCurrentPhase()
        addDebugLog("‚è∞ –°–∏—Å—Ç–µ–º–∞ –ø–ª–∞–Ω–∏—Ä—É–µ–º—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –æ—Ç–∫–ª—é—á–µ–Ω–∞ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –Ω–µ–º–µ–¥–ª–µ–Ω–Ω—ã–µ")
    }
    
    private func cancelNotification() {
        // Clear any pending UNUserNotificationCenter notifications
        UNUserNotificationCenter.current().removePendingNotificationRequests(
            withIdentifiers: ["timer-complete", "phase-complete"]
        )
        addDebugLog("üóëÔ∏è –ü–ª–∞–Ω–∏—Ä—É–µ–º—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—á–∏—â–µ–Ω—ã")
    }
    
    // MARK: - Statistics & Data
    
    private func recordCompletedSession() {
        let sessionMinutes = getCurrentPhaseMinutes()
        
        if currentPhase == .focus {
            todayFocusMinutes += sessionMinutes
            weekFocusMinutes += sessionMinutes
        }
        
        // Save to UserDefaults or Core Data
        saveStatistics()
    }
    
    private func getCurrentPhaseMinutes() -> Int {
        switch currentPhase {
        case .focus: return currentPreset.focusMinutes
        case .shortBreak: return currentPreset.shortBreakMinutes
        case .longBreak: return currentPreset.longBreakMinutes
        }
    }
    
    
    // MARK: - Persistence
    
    private func loadSettings() {
        let defaults = UserDefaults.standard
        soundEnabled = defaults.object(forKey: "soundEnabled") as? Bool ?? true
        notificationsEnabled = defaults.object(forKey: "notificationsEnabled") as? Bool ?? true
        autoStartBreaks = defaults.object(forKey: "autoStartBreaks") as? Bool ?? true
        autoStartFocus = defaults.object(forKey: "autoStartFocus") as? Bool ?? true
        
        if let presetName = defaults.string(forKey: "currentPreset") {
            switch presetName {
            case "classic": currentPreset = .classic
            case "deepWork": currentPreset = .deepWork  
            case "sprint": currentPreset = .sprint
            default: currentPreset = .classic
            }
        }
    }
    
    private func saveSettings() {
        let defaults = UserDefaults.standard
        defaults.set(soundEnabled, forKey: "soundEnabled")
        defaults.set(notificationsEnabled, forKey: "notificationsEnabled")
        defaults.set(autoStartBreaks, forKey: "autoStartBreaks")
        defaults.set(autoStartFocus, forKey: "autoStartFocus")
        
        let presetName: String
        switch currentPreset.name {
        case "25/5": presetName = "classic"
        case "50/10": presetName = "deepWork"
        case "15/3": presetName = "sprint"
        default: presetName = "classic"
        }
        defaults.set(presetName, forKey: "currentPreset")
    }
    
    private func loadStatistics() {
        let defaults = UserDefaults.standard
        completedCycles = defaults.integer(forKey: "completedCycles")
        todayFocusMinutes = defaults.integer(forKey: "todayFocusMinutes")
        weekFocusMinutes = defaults.integer(forKey: "weekFocusMinutes") 
        currentStreak = defaults.integer(forKey: "currentStreak")
    }
    
    private func saveStatistics() {
        let defaults = UserDefaults.standard
        defaults.set(completedCycles, forKey: "completedCycles")
        defaults.set(todayFocusMinutes, forKey: "todayFocusMinutes")
        defaults.set(weekFocusMinutes, forKey: "weekFocusMinutes")
        defaults.set(currentStreak, forKey: "currentStreak")
    }
    
    private func scheduleResetForTomorrow() {
        // Cancel existing reset timer
        dailyResetTimer?.invalidate()
        dailyResetTimer = nil

        let calendar = Calendar.current
        guard let tomorrow = calendar.date(byAdding: .day, value: 1, to: Date()) else {
            print("Failed to calculate tomorrow's date")
            return
        }
        let startOfTomorrow = calendar.startOfDay(for: tomorrow)
        let timeInterval = startOfTomorrow.timeIntervalSinceNow

        dailyResetTimer = Timer.scheduledTimer(withTimeInterval: timeInterval, repeats: false) { [weak self] _ in
            self?.resetForNewDay()
        }
    }
    
    @objc private func resetForNewDay() {
        timerState = .stopped
        // Archive today's stats, reset daily counters
        todayFocusMinutes = 0
        saveStatistics()
    }
}